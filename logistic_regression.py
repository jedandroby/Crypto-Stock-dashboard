
import streamlit as st
from datetime import date
import datetime
import plotly.graph_objects as go
import yfinance as yf
import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
from prophet import Prophet
from prophet.plot import plot_plotly
from PIL import Image
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn import metrics 
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import StandardScaler
from pandas.tseries.offsets import DateOffset
from sklearn import svm




def lr():
    START = "2010-01-01"
    TODAY = date.today().strftime("%Y-%m-%d")

    st.title("Logistic Regression Asset Predictor")

    stocks = ("BTC-USD","LINK-USD","SOL-USD","MATIC-USD","MANA-USD","DOT-USD","AVAX-USD","XLM-USD","LTC-USD","XRP-USD","BNB-USD","UNI-USD","ETH-USD","ADA-USD","USDC-USD","BAT-USD")
    selected_stocks = st.selectbox("Pick a coin for prediction",stocks)

    # n_days = st.slider("Days of Prediction:",1,7)
    # period = n_days * 365


    @st.cache(allow_output_mutation=True)
    def load_data(ticker):
        data = yf.download(ticker,START,TODAY)
        data.reset_index(inplace=True)
        # data = pd.DataFrame(data)
        return data
    
    

    # data_load_state = st.text("Load data")
    data = load_data(selected_stocks)
    # data_load_state.text("Loading data")
    st.subheader('Data Head')
    st.write(data.head())
    st.subheader('Data Tail')
    st.write(data.tail())
    
    def plot_raw_data():
        fig=go.Figure()
        fig.add_trace(go.Scatter(x=data["Date"],y=data['Open'], name='stock_open'))
        fig.add_trace(go.Scatter(x=data["Date"],y=data['Close'], name='stock_close'))
        fig.layout.update(title_text='Time Series Data', xaxis_rangeslider_visible=True)
        st.plotly_chart(fig)

    plot_raw_data()
    

    
    
    signal = data[["Date","Close"]]
    signal = signal.set_index("Date")
    
    signal['Actual Returns'] = signal.pct_change().dropna()
    short_window = 4
    long_window = 100
    signal['SMA_Fast'] = signal['Close'].rolling(window=short_window).mean()
    signal['SMA_Slow'] = signal['Close'].rolling(window=long_window).mean()
    signal = signal.dropna()
    signal['Signal'] = 0
    signal.loc[(signal['Actual Returns'] >= 0),'Signal'] = 1
    signal.loc[(signal['Actual Returns']< 0),'Signal'] = -1
    signal['Strategy Returns'] = signal['Actual Returns'] * signal['Signal'].shift()
    X = signal[['SMA_Fast','SMA_Slow']].shift().dropna()
    y = signal['Signal']
    
    training_begin = X.index.min()
    training_end = X.index.min() + DateOffset(months=3)
    
    

    X_train = X.loc[training_begin:training_end]
    y_train = y.loc[training_begin:training_end]
    X_test = X.loc[training_end+DateOffset(hours=1):]
    y_test = y.loc[training_end+DateOffset(hours=1):]

    scaler = StandardScaler()
    X_scaler = scaler.fit(X_train)
    X_train_scaled = X_scaler.transform(X_train)
    X_test_scaled = X_scaler.transform(X_test)

    lr_model = LogisticRegression()
    lr_model.fit(X_train_scaled,y_train)
    lr_pred = lr_model.predict(X_test_scaled)
    
    pred_df = pd.DataFrame(index=X_test.index)
    pred_df['Predictions'] = lr_pred
    pred_df['Actual Returns'] = signal['Actual Returns']
    pred_df ['Strategy Returns'] = (pred_df['Actual Returns']* pred_df['Predictions'])
    # st.write(pred_df)

    st.title('Explaining the model')
    st.write('Logistic Regression is a statistical model that is used for binary classification problems. A binary classification problem is one in which the outcome can only have two possible values, such as true or false, or 0 or 1.'
    'The basic idea behind the logistic regression model is to find the best coefficients (also known as weights or parameters) for the input features, so that the linear boundary that is generated by the model can correctly separate the data points into the two classes. The model is trained on a labeled dataset, where the outcome variable is known, and the goal is to find the coefficients that minimize the error between the predicted probabilities and the true labels.')

    st.title('Explaining the strategy')
    st.write('The strategy takes the percent change based on the coin of choice, then it sets windows to calculate the moving average'
    '.The next step that the strategy takes is creating a dataframe where it takes the actual returns and if these returns are greater then 0 then it gives us back 1,otherwise -1.')

    st.subheader('Actual Returns vs Strategy Returns')
    if st.button('Click to see Dataframe'):
        st.write(pred_df)

  
    

    # pred_df["Actual Returns Cumprod"] = (1 + pred_df["Actual Returns"]).cumprod()
    # pred_df["Strategy Returns Cumprod"] = np.cumprod(1 + pred_df["Strategy Returns"])
    
    # fig = go.Figure()
    # fig.add_trace(go.Scatter(x=pred_df.index, y=pred_df['Actual Returns Cumprod'], name='Actual Returns Cumprod', line=dict(color='blue')))
    # fig.add_trace(go.Scatter(x=pred_df.index, y=pred_df['Strategy Returns Cumprod'], name='Strategy Returns Cumprod', line=dict(color='red')))
    # fig.update_layout(title='Comparison of Actual Returns and Strategy Returns Cumprod',xaxis_title='Date',yaxis_title='Cumprod of Returns')
    # if st.button('Click here to see the plot'):
    #     st.plotly_chart(fig)
  
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=pred_df.index, y=pred_df['Actual Returns'], name='Actual Returns', line=dict(color='blue')))
    fig.add_trace(go.Scatter(x=pred_df.index, y=pred_df['Strategy Returns'], name='Strategy Returns', line=dict(color='red')))
    fig.update_layout(title='Comparison of Actual Returns and Strategy Returns',xaxis_title='Date',yaxis_title='Returns')
    if st.button('Click here to see the plot'):
        st.plotly_chart(fig)

lr()
